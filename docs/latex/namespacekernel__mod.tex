\hypertarget{namespacekernel__mod}{}\section{kernel\+\_\+mod Module Reference}
\label{namespacekernel__mod}\index{kernel\+\_\+mod@{kernel\+\_\+mod}}
\subsection*{Data Types}
\begin{DoxyCompactItemize}
\item 
type \mbox{\hyperlink{structkernel__mod_1_1kernel__class}{kernel\+\_\+class}}
\end{DoxyCompactItemize}
\subsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
real(prec) function, dimension(size(sv\%state, 1), size(sv\%state, 2)) \mbox{\hyperlink{namespacekernel__mod_ae17673ed6d32a4e7f6e54276e6430cc9}{runkernel}} (self, sv, bdata, time, dt)
\begin{DoxyCompactList}\small\item\em Adaptation from run\+Solver (Ricardo) method that evaluates the specific kernel, according to the selected kernel. \end{DoxyCompactList}\item 
real(prec) function, dimension(size(sv\%state, 1), size(sv\%state, 2)) \mbox{\hyperlink{namespacekernel__mod_aec47ab247a9afc2a7fdc272620b3c5e8}{lagrangiankinematic}} (self, sv, bdata, time, dt)
\begin{DoxyCompactList}\small\item\em Lagrangian Kernel, evaluate the velocities at given points using the interpolants and split the evaluation part from the solver module. \end{DoxyCompactList}\item 
real(prec) function, dimension(size(sv\%state, 1), size(sv\%state, 2)) \mbox{\hyperlink{namespacekernel__mod_a92805ef71e30527b27de4efd7561f8f7}{diffusionisotropic}} (self, sv, dt)
\begin{DoxyCompactList}\small\item\em Diffusion Kernel, computes the anisotropic diffusion assuming a constant diffusion coefficient. D = 1 m/s. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespacekernel__mod_a26c62a8eec723402e20142e68ba7ec65}{initkernel}} (self)
\begin{DoxyCompactList}\small\item\em Initializer method adpated from for solver kernel class. Sets the type of kernel and the interpolator to evaluate it. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function/\+Subroutine Documentation}
\mbox{\Hypertarget{namespacekernel__mod_a92805ef71e30527b27de4efd7561f8f7}\label{namespacekernel__mod_a92805ef71e30527b27de4efd7561f8f7}} 
\index{kernel\+\_\+mod@{kernel\+\_\+mod}!diffusionisotropic@{diffusionisotropic}}
\index{diffusionisotropic@{diffusionisotropic}!kernel\+\_\+mod@{kernel\+\_\+mod}}
\subsubsection{\texorpdfstring{diffusionisotropic()}{diffusionisotropic()}}
{\footnotesize\ttfamily real(prec) function, dimension(size(sv\%state,1),size(sv\%state,2)) kernel\+\_\+mod\+::diffusionisotropic (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structkernel__mod_1_1kernel__class}{kernel\+\_\+class}}), intent(inout)}]{self,  }\item[{type(statevector\+\_\+class), intent(in)}]{sv,  }\item[{real(prec), intent(in)}]{dt }\end{DoxyParamCaption})}



Diffusion Kernel, computes the anisotropic diffusion assuming a constant diffusion coefficient. D = 1 m/s. 

\begin{DoxyAuthor}{Author}
Daniel Garaboa Paz -\/ U\+SC 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,sv,dt} & \\
\hline
\end{DoxyParams}


Definition at line 136 of file kernel.\+f90.


\begin{DoxyCode}
136     \textcolor{keywordtype}{class}(kernel\_class), \textcolor{keywordtype}{intent(inout)} :: self
137     \textcolor{keywordtype}{type}(stateVector\_class), \textcolor{keywordtype}{intent(in)} :: sv
138     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{intent(in)} :: dt
139     \textcolor{keywordtype}{integer} :: np, i
140     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{allocatable} :: rand\_vel\_u, rand\_vel\_v,rand\_vel\_w
141     \textcolor{keywordtype}{real(prec)} :: D = 1.
142     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{dimension(size(sv%state,1),size(sv%state,2))} :: DiffusionIsotropic
143 
144     diffusionisotropic = 0.0
145     np = \textcolor{keyword}{size}(sv%active) \textcolor{comment}{!number of Tracers}
146     \textcolor{keyword}{allocate}(rand\_vel\_u(np), rand\_vel\_v(np), rand\_vel\_w(np))
147     \textcolor{keyword}{call }random\_number(rand\_vel\_u)
148     \textcolor{keyword}{call }random\_number(rand\_vel\_v)
149     \textcolor{keyword}{call }random\_number(rand\_vel\_w)
150     \textcolor{comment}{!update velocities}
151     \textcolor{comment}{! For the moment we set D = 1 m/s, then the D parameter}
152     \textcolor{comment}{! should be part of the array of tracers parameter}
153     diffusionisotropic(:,1) = utils%m2geo((2.*rand\_vel\_u-1.)*sqrt(2.*d/dt), sv%state(:,2), .false.)
154     diffusionisotropic(:,2) = utils%m2geo((2.*rand\_vel\_v-1.)*sqrt(2.*d/dt), sv%state(:,2), .true.)
155     \textcolor{comment}{!DiffusionIsotropic(:,3) = (2.*rand\_vel\_w-1.)*sqrt(2.*D*0.0005/dt)}
156     \textcolor{keywordflow}{where} (sv%state(:,6) /= 0.0) diffusionisotropic(:,3) = (2.*rand\_vel\_w-1.)*sqrt(2.*d*0.0005/dt)
157 
\end{DoxyCode}
\mbox{\Hypertarget{namespacekernel__mod_a26c62a8eec723402e20142e68ba7ec65}\label{namespacekernel__mod_a26c62a8eec723402e20142e68ba7ec65}} 
\index{kernel\+\_\+mod@{kernel\+\_\+mod}!initkernel@{initkernel}}
\index{initkernel@{initkernel}!kernel\+\_\+mod@{kernel\+\_\+mod}}
\subsubsection{\texorpdfstring{initkernel()}{initkernel()}}
{\footnotesize\ttfamily subroutine kernel\+\_\+mod\+::initkernel (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structkernel__mod_1_1kernel__class}{kernel\+\_\+class}}), intent(inout)}]{self }\end{DoxyParamCaption})}



Initializer method adpated from for solver kernel class. Sets the type of kernel and the interpolator to evaluate it. 

\begin{DoxyAuthor}{Author}
Daniel Garaboa Paz -\/ G\+F\+NL 
\end{DoxyAuthor}


Definition at line 167 of file kernel.\+f90.


\begin{DoxyCode}
167     \textcolor{keywordtype}{class}(kernel\_class), \textcolor{keywordtype}{intent(inout)} :: self
168     \textcolor{keywordtype}{type}(string) :: interpName
169     interpname = \textcolor{stringliteral}{'linear'}
170     \textcolor{keyword}{call }self%Interpolator%initialize(1,interpname)
\end{DoxyCode}
\mbox{\Hypertarget{namespacekernel__mod_aec47ab247a9afc2a7fdc272620b3c5e8}\label{namespacekernel__mod_aec47ab247a9afc2a7fdc272620b3c5e8}} 
\index{kernel\+\_\+mod@{kernel\+\_\+mod}!lagrangiankinematic@{lagrangiankinematic}}
\index{lagrangiankinematic@{lagrangiankinematic}!kernel\+\_\+mod@{kernel\+\_\+mod}}
\subsubsection{\texorpdfstring{lagrangiankinematic()}{lagrangiankinematic()}}
{\footnotesize\ttfamily real(prec) function, dimension(size(sv\%state,1),size(sv\%state,2)) kernel\+\_\+mod\+::lagrangiankinematic (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structkernel__mod_1_1kernel__class}{kernel\+\_\+class}}), intent(inout)}]{self,  }\item[{type(statevector\+\_\+class), intent(inout)}]{sv,  }\item[{type(\mbox{\hyperlink{structbackground__mod_1_1background__class}{background\+\_\+class}}), dimension(\+:), intent(in)}]{bdata,  }\item[{real(prec), intent(in)}]{time,  }\item[{real(prec), intent(in)}]{dt }\end{DoxyParamCaption})}



Lagrangian Kernel, evaluate the velocities at given points using the interpolants and split the evaluation part from the solver module. 

\begin{DoxyAuthor}{Author}
Daniel Garaboa Paz -\/ U\+SC 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,sv,bdata,time,dt} & \\
\hline
\end{DoxyParams}


Definition at line 76 of file kernel.\+f90.


\begin{DoxyCode}
76     \textcolor{keywordtype}{class}(kernel\_class), \textcolor{keywordtype}{intent(inout)} :: self
77     \textcolor{keywordtype}{type}(stateVector\_class), \textcolor{keywordtype}{intent(inout)} :: sv
78     \textcolor{keywordtype}{type}(background\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)} :: bdata
79     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{intent(in)} :: time, dt
80     \textcolor{keywordtype}{integer} :: np, nf, bkg, i
81     \textcolor{keywordtype}{real(prec)} :: maxLevel(2)
82     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{dimension(:,:)}, \textcolor{keywordtype}{allocatable} :: var\_dt
83     \textcolor{keywordtype}{type}(string), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{allocatable} :: var\_name
84     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{dimension(size(sv%state,1),size(sv%state,2))} :: LagrangianKinematic
85 
86     lagrangiankinematic = 0.0
87     \textcolor{comment}{!interpolate each background}
88     \textcolor{keywordflow}{do} bkg = 1, \textcolor{keyword}{size}(bdata)
89         np = \textcolor{keyword}{size}(sv%active) \textcolor{comment}{!number of Tracers}
90         nf = bdata(bkg)%fields%getSize() \textcolor{comment}{!number of fields to interpolate}
91         \textcolor{keyword}{allocate}(var\_dt(np,nf))
92         \textcolor{keyword}{allocate}(var\_name(nf))
93         \textcolor{comment}{!correcting for maximum admissible level in the background}
94         maxlevel = bdata(bkg)%getDimExtents(globals%Var%level, .false.)
95         \textcolor{keywordflow}{if} (maxlevel(2) /= mv) \textcolor{keywordflow}{where} (sv%state(:,3) > maxlevel(2)) sv%state(:,3) = maxlevel(2)-0.00001
96         \textcolor{comment}{!interpolating all of the data}
97         \textcolor{keyword}{call }self%Interpolator%run(sv%state, bdata(bkg), time, var\_dt, var\_name)
98         \textcolor{comment}{!write dx/dt}
99         nf = utils%find\_str(var\_name, globals%Var%u, .true.)
100         lagrangiankinematic(:,1) = utils%m2geo(var\_dt(:,nf), sv%state(:,2), .false.)
101         sv%state(:,4) = var\_dt(:,nf)
102         nf = utils%find\_str(var\_name, globals%Var%v, .true.)
103         lagrangiankinematic(:,2) = utils%m2geo(var\_dt(:,nf), sv%state(:,2), .true.)
104         sv%state(:,5) = var\_dt(:,nf)
105         nf = utils%find\_str(var\_name, globals%Var%w, .false.)
106         \textcolor{keywordflow}{if} (nf /= mv\_int) \textcolor{keywordflow}{then}
107             lagrangiankinematic(:,3) = var\_dt(:,nf)
108             sv%state(:,6) = var\_dt(:,nf)
109         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nf == mv\_int) \textcolor{keywordflow}{then}
110             lagrangiankinematic(:,3) = 0.0
111             sv%state(:,6) = 0.0
112 \textcolor{keywordflow}{        end if}
113         \textcolor{comment}{!update land mask status}
114         nf = utils%find\_str(var\_name, globals%Var%landMask, .false.)
115         \textcolor{keywordflow}{if} (nf /= mv\_int) sv%landMask = nint(var\_dt(:,nf))
116         \textcolor{keywordflow}{if} (nf == mv\_int) sv%landMask = globals%Mask%waterVal
117         \textcolor{comment}{!marking tracers for deletion because they are in land}
118         \textcolor{keywordflow}{where}(sv%landMask == 2) sv%active = .false.
119         \textcolor{comment}{!update land interaction status}
120         nf = utils%find\_str(var\_name, globals%Var%landIntMask, .false.)
121         \textcolor{keywordflow}{if} (nf /= mv\_int) sv%landIntMask = nint(var\_dt(:,nf))
122         \textcolor{keywordflow}{if} (nf == mv\_int) sv%landIntMask = globals%Mask%waterVal
123         \textcolor{comment}{!update other vars...}
124 \textcolor{keywordflow}{    end do}
125 
\end{DoxyCode}
\mbox{\Hypertarget{namespacekernel__mod_ae17673ed6d32a4e7f6e54276e6430cc9}\label{namespacekernel__mod_ae17673ed6d32a4e7f6e54276e6430cc9}} 
\index{kernel\+\_\+mod@{kernel\+\_\+mod}!runkernel@{runkernel}}
\index{runkernel@{runkernel}!kernel\+\_\+mod@{kernel\+\_\+mod}}
\subsubsection{\texorpdfstring{runkernel()}{runkernel()}}
{\footnotesize\ttfamily real(prec) function, dimension(size(sv\%state,1),size(sv\%state,2)) kernel\+\_\+mod\+::runkernel (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structkernel__mod_1_1kernel__class}{kernel\+\_\+class}}), intent(inout)}]{self,  }\item[{type(statevector\+\_\+class), intent(inout)}]{sv,  }\item[{type(\mbox{\hyperlink{structbackground__mod_1_1background__class}{background\+\_\+class}}), dimension(\+:), intent(in)}]{bdata,  }\item[{real(prec), intent(in)}]{time,  }\item[{real(prec), intent(in)}]{dt }\end{DoxyParamCaption})}



Adaptation from run\+Solver (Ricardo) method that evaluates the specific kernel, according to the selected kernel. 

\begin{DoxyAuthor}{Author}
Daniel Garaboa Paz -\/ G\+F\+NL 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,sv,bdata,time,dt} & \\
\hline
\end{DoxyParams}


Definition at line 52 of file kernel.\+f90.


\begin{DoxyCode}
52     \textcolor{keywordtype}{class}(kernel\_class), \textcolor{keywordtype}{intent(inout)} :: self
53     \textcolor{keywordtype}{type}(stateVector\_class), \textcolor{keywordtype}{intent(inout)} :: sv
54     \textcolor{keywordtype}{type}(background\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)} :: bdata
55     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{intent(in)} :: time, dt
56     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{dimension(size(sv%state,1),size(sv%state,2))} :: runKernel
57 
58     \textcolor{keywordflow}{if} (sv%ttype == globals%Types%base) \textcolor{keywordflow}{then}
59         runkernel = self%LagrangianKinematic(sv, bdata, time, dt) \textcolor{comment}{!+ self%DiffusionIsotropic(sv, dt)}
60     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (sv%ttype == globals%Types%paper) \textcolor{keywordflow}{then}
61         runkernel = self%LagrangianKinematic(sv, bdata, time, dt) \textcolor{comment}{!+ self%DiffusionIsotropic(sv, dt)}
62     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (sv%ttype == globals%Types%plastic) \textcolor{keywordflow}{then}
63         runkernel = self%LagrangianKinematic(sv, bdata, time, dt) \textcolor{comment}{!+ self%DiffusionIsotropic(sv, dt)}
64 \textcolor{keywordflow}{    end if}
65 
\end{DoxyCode}
