\hypertarget{namespacesolver__mod}{}\section{solver\+\_\+mod Module Reference}
\label{namespacesolver__mod}\index{solver\+\_\+mod@{solver\+\_\+mod}}


Defines an Solver class. This class invokes the different available integration algorithms as methods, and these invoke the necessary kernel functions.  


\subsection*{Data Types}
\begin{DoxyCompactItemize}
\item 
type \mbox{\hyperlink{structsolver__mod_1_1solver__class}{solver\+\_\+class}}
\end{DoxyCompactItemize}
\subsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
subroutine \mbox{\hyperlink{namespacesolver__mod_a75c5c8b01ae4ae193ff03dbe7e5fc6af}{runstep}} (self, state, bdata, time, dt)
\begin{DoxyCompactList}\small\item\em Method that integrates the Tracer State Vector in one time-\/step, according to the selected integration algorithm. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespacesolver__mod_a21533e195501ebb46c1814aeaede4c55}{runstepeuler}} (self, sv, bdata, time, dt)
\begin{DoxyCompactList}\small\item\em Method that integrates the Tracer state array in one time-\/step, using a Velocity Euler integration algorithm. This is a one-\/shot type explicit scheme with low computational cost. Implements $ {\vec {x}}_{t+\Delta t}={\vec {x}}_{t}+{\vec {v}}_{t}\Delta t+{\frac {1}{2}}{\vec {a}}({\vec {x}}_{t})\Delta t^{2}$ $ {\vec {v}}_{t+\Delta t}={\vec {v}}_{t}+\frac{{\vec {a}}_{t+\Delta t}+{\vec {a}}_{t}}{2}\Delta t$. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespacesolver__mod_ae574f8d772b89d5c3c602db278c05325}{runstepmseuler}} (self, sv, bdata, time, dt)
\begin{DoxyCompactList}\small\item\em Method that integrates the Tracer state vector in one time-\/step, using a Multi-\/\+Step Euler integration algorithm. This is a predictor-\/corrector type explicit scheme with excelent conservation properties and average cost. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespacesolver__mod_a11436fc89bf6c713930a83b5cc52a0cd}{runsteprk4}} (self, sv, bdata, time, dt)
\begin{DoxyCompactList}\small\item\em Method that integrates the Tracer state array in one time-\/step, using a Runge-\/\+Kuta 4th order integration algorithm. This is an explicit scheme with medium to high computational cost. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespacesolver__mod_a326292ff19880a914317109520b200b2}{initsolver}} (self, flag, name)
\begin{DoxyCompactList}\small\item\em Initializer method for the Solver class. Sets the type of integrator and name of the algorithm this Solver will call. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespacesolver__mod_a54ea6899cce026a7a5da2dd05922628f}{printsolver}} (self)
\begin{DoxyCompactList}\small\item\em Method that prints the Solver information. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Defines an Solver class. This class invokes the different available integration algorithms as methods, and these invoke the necessary kernel functions. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas 
\end{DoxyAuthor}


\subsection{Function/\+Subroutine Documentation}
\mbox{\Hypertarget{namespacesolver__mod_a326292ff19880a914317109520b200b2}\label{namespacesolver__mod_a326292ff19880a914317109520b200b2}} 
\index{solver\+\_\+mod@{solver\+\_\+mod}!initsolver@{initsolver}}
\index{initsolver@{initsolver}!solver\+\_\+mod@{solver\+\_\+mod}}
\subsubsection{\texorpdfstring{initsolver()}{initsolver()}}
{\footnotesize\ttfamily subroutine solver\+\_\+mod\+::initsolver (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structsolver__mod_1_1solver__class}{solver\+\_\+class}}), intent(inout)}]{self,  }\item[{integer, intent(in)}]{flag,  }\item[{type(string), intent(in)}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Initializer method for the Solver class. Sets the type of integrator and name of the algorithm this Solver will call. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,flag,name} & \\
\hline
\end{DoxyParams}


Definition at line 185 of file solver.\+f90.


\begin{DoxyCode}
185     \textcolor{keywordtype}{class}(solver\_class), \textcolor{keywordtype}{intent(inout)} :: self
186     \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: flag
187     \textcolor{keywordtype}{type}(string), \textcolor{keywordtype}{intent(in)} :: name
188     \textcolor{keywordtype}{type}(string) :: interpName
189     self%solverType = flag
190     self%name = name
191     \textcolor{keyword}{call }self%Kernel%initialize()
\end{DoxyCode}
\mbox{\Hypertarget{namespacesolver__mod_a54ea6899cce026a7a5da2dd05922628f}\label{namespacesolver__mod_a54ea6899cce026a7a5da2dd05922628f}} 
\index{solver\+\_\+mod@{solver\+\_\+mod}!printsolver@{printsolver}}
\index{printsolver@{printsolver}!solver\+\_\+mod@{solver\+\_\+mod}}
\subsubsection{\texorpdfstring{printsolver()}{printsolver()}}
{\footnotesize\ttfamily subroutine solver\+\_\+mod\+::printsolver (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structsolver__mod_1_1solver__class}{solver\+\_\+class}}), intent(inout)}]{self }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Method that prints the Solver information. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC 
\end{DoxyAuthor}


Definition at line 200 of file solver.\+f90.


\begin{DoxyCode}
200     \textcolor{keywordtype}{class}(solver\_class), \textcolor{keywordtype}{intent(inout)} :: self
201     \textcolor{keywordtype}{type}(string) :: outext, t
202     outext = \textcolor{stringliteral}{'Solver algorithm is '}//self%name
203     \textcolor{keyword}{call }log%put(outext,.false.)
\end{DoxyCode}
\mbox{\Hypertarget{namespacesolver__mod_a75c5c8b01ae4ae193ff03dbe7e5fc6af}\label{namespacesolver__mod_a75c5c8b01ae4ae193ff03dbe7e5fc6af}} 
\index{solver\+\_\+mod@{solver\+\_\+mod}!runstep@{runstep}}
\index{runstep@{runstep}!solver\+\_\+mod@{solver\+\_\+mod}}
\subsubsection{\texorpdfstring{runstep()}{runstep()}}
{\footnotesize\ttfamily subroutine solver\+\_\+mod\+::runstep (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structsolver__mod_1_1solver__class}{solver\+\_\+class}}), intent(inout)}]{self,  }\item[{type(statevector\+\_\+class), dimension(\+:), intent(inout)}]{state,  }\item[{type(\mbox{\hyperlink{structbackground__mod_1_1background__class}{background\+\_\+class}}), dimension(\+:), intent(in)}]{bdata,  }\item[{real(prec), intent(in)}]{time,  }\item[{real(prec), intent(in)}]{dt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Method that integrates the Tracer State Vector in one time-\/step, according to the selected integration algorithm. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,state,bdata,time,dt} & \\
\hline
\end{DoxyParams}


Definition at line 58 of file solver.\+f90.


\begin{DoxyCode}
58     \textcolor{keywordtype}{class}(solver\_class), \textcolor{keywordtype}{intent(inout)} :: self
59     \textcolor{keywordtype}{type}(stateVector\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(inout)} :: state
60     \textcolor{keywordtype}{type}(background\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)} :: bdata
61     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{intent(in)} :: time, dt
62     \textcolor{comment}{!so the forward integrators don't overextend beyond calendar time}
63     \textcolor{keywordflow}{if} (time+dt < globals%Parameters%TimeMax) \textcolor{keywordflow}{then}
64         \textcolor{keywordflow}{if} (self%solverType == 1) \textcolor{keyword}{call }self%runStepEuler(state, bdata, time, dt)
65         \textcolor{keywordflow}{if} (self%solverType == 2) \textcolor{keyword}{call }self%runStepMSEuler(state, bdata, time, dt)
66         \textcolor{keywordflow}{if} (self%solverType == 3) \textcolor{keyword}{call }self%runStepRK4(state, bdata, time, dt)
67 \textcolor{keywordflow}{    end if}
\end{DoxyCode}
\mbox{\Hypertarget{namespacesolver__mod_a21533e195501ebb46c1814aeaede4c55}\label{namespacesolver__mod_a21533e195501ebb46c1814aeaede4c55}} 
\index{solver\+\_\+mod@{solver\+\_\+mod}!runstepeuler@{runstepeuler}}
\index{runstepeuler@{runstepeuler}!solver\+\_\+mod@{solver\+\_\+mod}}
\subsubsection{\texorpdfstring{runstepeuler()}{runstepeuler()}}
{\footnotesize\ttfamily subroutine solver\+\_\+mod\+::runstepeuler (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structsolver__mod_1_1solver__class}{solver\+\_\+class}}), intent(inout)}]{self,  }\item[{type(statevector\+\_\+class), dimension(\+:), intent(inout)}]{sv,  }\item[{type(\mbox{\hyperlink{structbackground__mod_1_1background__class}{background\+\_\+class}}), dimension(\+:), intent(in)}]{bdata,  }\item[{real(prec), intent(in)}]{time,  }\item[{real(prec), intent(in)}]{dt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Method that integrates the Tracer state array in one time-\/step, using a Velocity Euler integration algorithm. This is a one-\/shot type explicit scheme with low computational cost. Implements $ {\vec {x}}_{t+\Delta t}={\vec {x}}_{t}+{\vec {v}}_{t}\Delta t+{\frac {1}{2}}{\vec {a}}({\vec {x}}_{t})\Delta t^{2}$ $ {\vec {v}}_{t+\Delta t}={\vec {v}}_{t}+\frac{{\vec {a}}_{t+\Delta t}+{\vec {a}}_{t}}{2}\Delta t$. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,sv,bdata,time,dt} & \\
\hline
\end{DoxyParams}


Definition at line 81 of file solver.\+f90.


\begin{DoxyCode}
81     \textcolor{keywordtype}{class}(solver\_class), \textcolor{keywordtype}{intent(inout)} :: self
82     \textcolor{keywordtype}{type}(stateVector\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(inout)} :: sv
83     \textcolor{keywordtype}{type}(background\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)} :: bdata
84     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{intent(in)} :: time, dt
85     \textcolor{keywordtype}{integer} :: i
86 
87     \textcolor{keywordflow}{do} i=1, \textcolor{keyword}{size}(sv)
88         sv(i)%state = sv(i)%state + self%Kernel%run(sv(i), bdata, time, dt)*dt
89 \textcolor{keywordflow}{    end do}
90 
\end{DoxyCode}
\mbox{\Hypertarget{namespacesolver__mod_ae574f8d772b89d5c3c602db278c05325}\label{namespacesolver__mod_ae574f8d772b89d5c3c602db278c05325}} 
\index{solver\+\_\+mod@{solver\+\_\+mod}!runstepmseuler@{runstepmseuler}}
\index{runstepmseuler@{runstepmseuler}!solver\+\_\+mod@{solver\+\_\+mod}}
\subsubsection{\texorpdfstring{runstepmseuler()}{runstepmseuler()}}
{\footnotesize\ttfamily subroutine solver\+\_\+mod\+::runstepmseuler (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structsolver__mod_1_1solver__class}{solver\+\_\+class}}), intent(inout)}]{self,  }\item[{type(statevector\+\_\+class), dimension(\+:), intent(inout)}]{sv,  }\item[{type(\mbox{\hyperlink{structbackground__mod_1_1background__class}{background\+\_\+class}}), dimension(\+:), intent(in)}]{bdata,  }\item[{real(prec), intent(in)}]{time,  }\item[{real(prec), intent(in)}]{dt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Method that integrates the Tracer state vector in one time-\/step, using a Multi-\/\+Step Euler integration algorithm. This is a predictor-\/corrector type explicit scheme with excelent conservation properties and average cost. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,sv,bdata,time,dt} & \\
\hline
\end{DoxyParams}


Definition at line 102 of file solver.\+f90.


\begin{DoxyCode}
102     \textcolor{keywordtype}{class}(solver\_class), \textcolor{keywordtype}{intent(inout)} :: self
103     \textcolor{keywordtype}{type}(stateVector\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(inout)} :: sv
104     \textcolor{keywordtype}{type}(background\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)} :: bdata
105     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{intent(in)} :: time, dt
106     \textcolor{keywordtype}{type}(stateVector\_class) :: predSv
107     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{allocatable}, \textcolor{keywordtype}{dimension(:,:)} :: predKernel
108     \textcolor{keywordtype}{real(prec)}:: mstime
109     \textcolor{keywordtype}{integer} :: i
110 
111     mstime = time + 0.5*dt
112 
113     \textcolor{keywordflow}{do} i=1, \textcolor{keyword}{size}(sv)
114         \textcolor{comment}{!creating predictor step state vector}
115         \textcolor{keyword}{call }sv(i)%copyState(predsv)
116         \textcolor{keyword}{allocate}(predkernel(\textcolor{keyword}{size}(sv(i)%state, 1), \textcolor{keyword}{size}(sv(i)%state, 2)))
117         \textcolor{comment}{!computing predictor step}
118         predkernel = self%Kernel%run(sv(i), bdata, time, dt)
119         predsv%state = sv(i)%state + predkernel*dt
120         \textcolor{comment}{!computing corrector step}
121         sv(i)%state = sv(i)%state + (predkernel +  self%Kernel%run(predsv, bdata, mstime, dt))*(dt*0.5)
122         \textcolor{comment}{!deallocating}
123         \textcolor{keyword}{call }predsv%finalize()
124         \textcolor{keyword}{deallocate}(predkernel)
125 \textcolor{keywordflow}{    end do}
126 
\end{DoxyCode}
\mbox{\Hypertarget{namespacesolver__mod_a11436fc89bf6c713930a83b5cc52a0cd}\label{namespacesolver__mod_a11436fc89bf6c713930a83b5cc52a0cd}} 
\index{solver\+\_\+mod@{solver\+\_\+mod}!runsteprk4@{runsteprk4}}
\index{runsteprk4@{runsteprk4}!solver\+\_\+mod@{solver\+\_\+mod}}
\subsubsection{\texorpdfstring{runsteprk4()}{runsteprk4()}}
{\footnotesize\ttfamily subroutine solver\+\_\+mod\+::runsteprk4 (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structsolver__mod_1_1solver__class}{solver\+\_\+class}}), intent(inout)}]{self,  }\item[{type(statevector\+\_\+class), dimension(\+:), intent(inout)}]{sv,  }\item[{type(\mbox{\hyperlink{structbackground__mod_1_1background__class}{background\+\_\+class}}), dimension(\+:), intent(in)}]{bdata,  }\item[{real(prec), intent(in)}]{time,  }\item[{real(prec), intent(in)}]{dt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Method that integrates the Tracer state array in one time-\/step, using a Runge-\/\+Kuta 4th order integration algorithm. This is an explicit scheme with medium to high computational cost. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC 
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em self,sv,bdata,time,dt} & \\
\hline
\end{DoxyParams}


Definition at line 139 of file solver.\+f90.


\begin{DoxyCode}
139     \textcolor{keywordtype}{class}(solver\_class), \textcolor{keywordtype}{intent(inout)} :: self
140     \textcolor{keywordtype}{type}(stateVector\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(inout)} :: sv
141     \textcolor{keywordtype}{type}(background\_class), \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)} :: bdata
142     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{intent(in)} :: time, dt
143     \textcolor{keywordtype}{type}(stateVector\_class) :: intSv
144     \textcolor{keywordtype}{real(prec)}, \textcolor{keywordtype}{allocatable}, \textcolor{keywordtype}{dimension(:,:)} :: k1, k2, k3, k4
145     \textcolor{keywordtype}{integer} :: i
146 
147     \textcolor{keywordflow}{do} i=1, \textcolor{keyword}{size}(sv)
148         \textcolor{comment}{!creating intermediate step state vectors}
149         \textcolor{keyword}{call }sv(i)%copyState(intsv)
150         \textcolor{keyword}{allocate}(k1(\textcolor{keyword}{size}(sv(i)%state, 1), \textcolor{keyword}{size}(sv(i)%state, 2)))
151         \textcolor{keyword}{allocate}(k2(\textcolor{keyword}{size}(sv(i)%state, 1), \textcolor{keyword}{size}(sv(i)%state, 2)))
152         \textcolor{keyword}{allocate}(k3(\textcolor{keyword}{size}(sv(i)%state, 1), \textcolor{keyword}{size}(sv(i)%state, 2)))
153         \textcolor{keyword}{allocate}(k4(\textcolor{keyword}{size}(sv(i)%state, 1), \textcolor{keyword}{size}(sv(i)%state, 2)))
154         \textcolor{comment}{!1st step}
155         k1 = self%Kernel%run(sv(i), bdata, time, dt)*dt
156         intsv%state = sv(i)%state + k1*0.5
157         \textcolor{comment}{!2nd step}
158         k2 = self%Kernel%run(intsv, bdata, time + 0.5*dt, dt)*dt
159         intsv%state = sv(i)%state + k2*0.5
160         \textcolor{comment}{!3rd step}
161         k3 = self%Kernel%run(intsv, bdata, time + 0.5*dt, dt)*dt
162         intsv%state = sv(i)%state + k3
163         \textcolor{comment}{!4th step}
164         k4 = self%Kernel%run(intsv, bdata, time + dt, dt)*dt
165         \textcolor{comment}{!computing the new state}
166         sv(i)%state = sv(i)%state + (k1 + 2.0*k2 + 2.0*k3 + k4)/6.0
167         \textcolor{comment}{!deallocating}
168         \textcolor{keyword}{call }intsv%finalize()
169         \textcolor{keyword}{deallocate}(k1)
170         \textcolor{keyword}{deallocate}(k2)
171         \textcolor{keyword}{deallocate}(k3)
172         \textcolor{keyword}{deallocate}(k4)
173 \textcolor{keywordflow}{    end do}
174 
\end{DoxyCode}
