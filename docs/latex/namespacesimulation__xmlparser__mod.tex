\hypertarget{namespacesimulation__xmlparser__mod}{}\section{simulation\+\_\+xmlparser\+\_\+mod Module Reference}
\label{namespacesimulation__xmlparser__mod}\index{simulation\+\_\+xmlparser\+\_\+mod@{simulation\+\_\+xmlparser\+\_\+mod}}


Module with the simulation xml parsing related definitions and routines.  


\subsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
subroutine, public \mbox{\hyperlink{namespacesimulation__xmlparser__mod_ab062c8e064b043446d4f6ac695b306ab}{readxmlatt}} (xmlnode, tag, att\+\_\+name, att\+\_\+value, read\+\_\+flag, mandatory)
\begin{DoxyCompactList}\small\item\em Private attribute xml parser routine. In the format $<$Tag att\+\_\+name=\char`\"{}att\+\_\+value\char`\"{}. \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacesimulation__xmlparser__mod_a48bcd153bef2149410d66842b564728d}{readxmlvector}} (xmlnode, tag, vec, read\+\_\+flag, mandatory)
\begin{DoxyCompactList}\small\item\em Private vector xml parser routine. Vector must be in format $<$\+Tag x=\char`\"{}vec\%x\char`\"{} y=\char`\"{}vec\%y\char`\"{} z=\char`\"{}vec\%z\char`\"{}$>$ \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacesimulation__xmlparser__mod_a3167fcb99b40cdc25d2ba18418bd8b9f}{gotochildnode}} (current\+Node, target\+Node, target\+Node\+Name, read\+\_\+flag, mandatory)
\begin{DoxyCompactList}\small\item\em Private routine to retrieve a node within a node. Returns a nullifyed pointer if not found, stops if mandatory. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Module with the simulation xml parsing related definitions and routines. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas 
\end{DoxyAuthor}


\subsection{Function/\+Subroutine Documentation}
\mbox{\Hypertarget{namespacesimulation__xmlparser__mod_a3167fcb99b40cdc25d2ba18418bd8b9f}\label{namespacesimulation__xmlparser__mod_a3167fcb99b40cdc25d2ba18418bd8b9f}} 
\index{simulation\+\_\+xmlparser\+\_\+mod@{simulation\+\_\+xmlparser\+\_\+mod}!gotochildnode@{gotochildnode}}
\index{gotochildnode@{gotochildnode}!simulation\+\_\+xmlparser\+\_\+mod@{simulation\+\_\+xmlparser\+\_\+mod}}
\subsubsection{\texorpdfstring{gotochildnode()}{gotochildnode()}}
{\footnotesize\ttfamily subroutine, public simulation\+\_\+xmlparser\+\_\+mod\+::gotochildnode (\begin{DoxyParamCaption}\item[{type(node), intent(in), pointer}]{current\+Node,  }\item[{type(node), intent(out), pointer}]{target\+Node,  }\item[{type(string), intent(in)}]{target\+Node\+Name,  }\item[{logical, intent(out), optional}]{read\+\_\+flag,  }\item[{logical, intent(in), optional}]{mandatory }\end{DoxyParamCaption})}



Private routine to retrieve a node within a node. Returns a nullifyed pointer if not found, stops if mandatory. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em current\+Node,target\+Node,target\+Node\+Name,mandatory} & \\
\hline
\mbox{\tt out}  & {\em read\+\_\+flag} & Optional flag to capture read/non-\/read status\\
\hline
\mbox{\tt in}  & {\em mandatory} & Swich for optional or mandatory tags \\
\hline
\end{DoxyParams}


Definition at line 162 of file simulation\+\_\+xmlparser.\+f90.


\begin{DoxyCode}
162     \textcolor{keywordtype}{implicit none}
163     \textcolor{keywordtype}{type}(Node), \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{pointer} :: currentNode
164     \textcolor{keywordtype}{type}(Node), \textcolor{keywordtype}{intent(out)}, \textcolor{keywordtype}{pointer} :: targetNode
165     \textcolor{keywordtype}{type}(string), \textcolor{keywordtype}{intent(in)} :: targetNodeName
166     \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{intent(out)}, \textcolor{keywordtype}{optional} :: read\_flag
167     \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{optional} :: mandatory
168 
169     \textcolor{keywordtype}{type}(NodeList), \textcolor{keywordtype}{pointer} :: target\_node\_list
170     \textcolor{keywordtype}{type}(string) :: outext, nodename
171     \textcolor{keywordtype}{integer} :: i
172     \textcolor{keywordtype}{logical} :: target\_node\_exists
173 
174     target\_node\_exists = .false.
175     target\_node\_list => getchildnodes(currentnode)
176     \textcolor{keywordflow}{do} i=0, getlength(target\_node\_list)-1
177         targetnode => item(target\_node\_list,i) \textcolor{comment}{!grabing a node}
178         nodename = getlocalname(targetnode)  \textcolor{comment}{!finding its name}
179         \textcolor{keywordflow}{if} (nodename == targetnodename) \textcolor{keywordflow}{then} \textcolor{comment}{!found our target node}
180             target\_node\_exists = .true.
181             \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(read\_flag)) \textcolor{keywordflow}{then}
182               read\_flag =.true.
183 \textcolor{keywordflow}{            endif}
184             \textcolor{keywordflow}{exit}
185 \textcolor{keywordflow}{        endif}
186 \textcolor{keywordflow}{    enddo}
187     \textcolor{keywordflow}{if} (target\_node\_exists .eqv. .false.) \textcolor{keywordflow}{then}
188         \textcolor{keyword}{nullify}(targetnode)
189         \textcolor{keywordflow}{if}(\textcolor{keyword}{present}(mandatory)) \textcolor{keywordflow}{then}
190           \textcolor{keywordflow}{if} (mandatory.eqv..false.) \textcolor{keywordflow}{then}
191             outext=\textcolor{stringliteral}{'Could not find any node called "'}//targetnodename//\textcolor{stringliteral}{'" in the xml file, ignoring'}
192             \textcolor{keyword}{call }log%put(outext)
193             \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(read\_flag)) \textcolor{keywordflow}{then}
194               read\_flag =.false.
195 \textcolor{keywordflow}{            endif}
196           \textcolor{keywordflow}{else}
197             outext=\textcolor{stringliteral}{'Could not find any node called "'}//targetnodename//\textcolor{stringliteral}{'" in the xml file, stoping'}
198             \textcolor{keyword}{call }log%put(outext)
199             stop
200 \textcolor{keywordflow}{          endif}
201         \textcolor{keywordflow}{else}
202           outext=\textcolor{stringliteral}{'Could not find any node called "'}//targetnodename//\textcolor{stringliteral}{'" in the xml file, stoping'}
203           \textcolor{keyword}{call }log%put(outext)
204           stop
205 \textcolor{keywordflow}{        endif}
206 \textcolor{keywordflow}{    endif}
207 
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacesimulation__xmlparser__mod_a3167fcb99b40cdc25d2ba18418bd8b9f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacesimulation__xmlparser__mod_ab062c8e064b043446d4f6ac695b306ab}\label{namespacesimulation__xmlparser__mod_ab062c8e064b043446d4f6ac695b306ab}} 
\index{simulation\+\_\+xmlparser\+\_\+mod@{simulation\+\_\+xmlparser\+\_\+mod}!readxmlatt@{readxmlatt}}
\index{readxmlatt@{readxmlatt}!simulation\+\_\+xmlparser\+\_\+mod@{simulation\+\_\+xmlparser\+\_\+mod}}
\subsubsection{\texorpdfstring{readxmlatt()}{readxmlatt()}}
{\footnotesize\ttfamily subroutine, public simulation\+\_\+xmlparser\+\_\+mod\+::readxmlatt (\begin{DoxyParamCaption}\item[{type(node), intent(in), pointer}]{xmlnode,  }\item[{type(string), intent(in)}]{tag,  }\item[{type(string), intent(in)}]{att\+\_\+name,  }\item[{type(string), intent(out)}]{att\+\_\+value,  }\item[{logical, intent(out), optional}]{read\+\_\+flag,  }\item[{logical, intent(in), optional}]{mandatory }\end{DoxyParamCaption})}



Private attribute xml parser routine. In the format $<$Tag att\+\_\+name=\char`\"{}att\+\_\+value\char`\"{}. 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em xmlnode,tag,vec,mandatory} & \\
\hline
\mbox{\tt in}  & {\em xmlnode} & Working xml node\\
\hline
\mbox{\tt in}  & {\em tag} & Tag to search in xml node\\
\hline
\mbox{\tt in}  & {\em att\+\_\+name} & Atribute name to collect from tag\\
\hline
\mbox{\tt out}  & {\em att\+\_\+value} & Attribute value\\
\hline
\mbox{\tt out}  & {\em read\+\_\+flag} & Optional flag to capture read/non-\/read status\\
\hline
\mbox{\tt in}  & {\em mandatory} & Swich for optional or mandatory tags \\
\hline
\end{DoxyParams}


Definition at line 43 of file simulation\+\_\+xmlparser.\+f90.


\begin{DoxyCode}
43     \textcolor{keywordtype}{implicit none}
44     \textcolor{keywordtype}{type}(Node), \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{pointer} :: xmlnode
45     \textcolor{keywordtype}{type}(string), \textcolor{keywordtype}{intent(in)} :: tag
46     \textcolor{keywordtype}{type}(string), \textcolor{keywordtype}{intent(in)} :: att\_name
47     \textcolor{keywordtype}{type}(string), \textcolor{keywordtype}{intent(out)} :: att\_value
48     \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{intent(out)}, \textcolor{keywordtype}{optional} :: read\_flag
49     \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{optional} :: mandatory
50 
51     \textcolor{keywordtype}{type}(string) :: outext, nodename
52     \textcolor{keywordtype}{character(80)} :: att\_value\_chars
53     \textcolor{keywordtype}{type}(NodeList), \textcolor{keywordtype}{pointer} :: target\_node\_list, nodeChildren
54     \textcolor{keywordtype}{type}(Node), \textcolor{keywordtype}{pointer} :: nodedetail
55     \textcolor{keywordtype}{logical} :: validtag
56     \textcolor{keywordtype}{integer} :: i
57 
58     validtag = .false.
59     nodechildren => getchildnodes(xmlnode) \textcolor{comment}{!getting all of the nodes bellow the main source node (all of
       it's private info)}
60     \textcolor{keywordflow}{do} i=0, getlength(nodechildren)-1
61         nodedetail => item(nodechildren,i) \textcolor{comment}{!grabing a node}
62         nodename = getlocalname(nodedetail)  \textcolor{comment}{!finding its name}
63         \textcolor{keywordflow}{if} (nodename == tag) \textcolor{keywordflow}{then}
64             validtag=.true.
65             \textcolor{keywordflow}{exit}
66 \textcolor{keywordflow}{        endif}
67 \textcolor{keywordflow}{    enddo}
68     \textcolor{keywordflow}{if} (validtag) \textcolor{keywordflow}{then}
69         target\_node\_list => getelementsbytagname(xmlnode, tag%chars())   \textcolor{comment}{!searching for tags with the given
       name}
70         nodedetail => item(target\_node\_list, 0)
71         \textcolor{keyword}{call }extractdataattribute(nodedetail, att\_name%chars(), att\_value\_chars)
72         att\_value=trim(att\_value\_chars)
73         \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(read\_flag)) \textcolor{keywordflow}{then}
74           read\_flag =.true.
75 \textcolor{keywordflow}{        endif}
76     \textcolor{keywordflow}{else}
77         \textcolor{keywordflow}{if}(\textcolor{keyword}{present}(mandatory)) \textcolor{keywordflow}{then}
78             \textcolor{keywordflow}{if}(mandatory.eqv..false.) \textcolor{keywordflow}{then}
79               \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(read\_flag)) \textcolor{keywordflow}{then}
80                 read\_flag =.false.
81 \textcolor{keywordflow}{              endif}
82 \textcolor{keywordflow}{            endif}
83         \textcolor{keywordflow}{else}
84             outext=\textcolor{stringliteral}{'Could not find any "'}//tag//\textcolor{stringliteral}{'" tag for xml node "'}//getnodename(xmlnode)//\textcolor{stringliteral}{'", stoping'}
85             \textcolor{keyword}{call }log%put(outext)
86             stop
87 \textcolor{keywordflow}{        endif}
88 \textcolor{keywordflow}{    endif}
89 
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacesimulation__xmlparser__mod_ab062c8e064b043446d4f6ac695b306ab_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacesimulation__xmlparser__mod_a48bcd153bef2149410d66842b564728d}\label{namespacesimulation__xmlparser__mod_a48bcd153bef2149410d66842b564728d}} 
\index{simulation\+\_\+xmlparser\+\_\+mod@{simulation\+\_\+xmlparser\+\_\+mod}!readxmlvector@{readxmlvector}}
\index{readxmlvector@{readxmlvector}!simulation\+\_\+xmlparser\+\_\+mod@{simulation\+\_\+xmlparser\+\_\+mod}}
\subsubsection{\texorpdfstring{readxmlvector()}{readxmlvector()}}
{\footnotesize\ttfamily subroutine, public simulation\+\_\+xmlparser\+\_\+mod\+::readxmlvector (\begin{DoxyParamCaption}\item[{type(node), intent(in), pointer}]{xmlnode,  }\item[{type(string), intent(in)}]{tag,  }\item[{type(vector), intent(out)}]{vec,  }\item[{logical, intent(out), optional}]{read\+\_\+flag,  }\item[{logical, intent(in), optional}]{mandatory }\end{DoxyParamCaption})}



Private vector xml parser routine. Vector must be in format $<$\+Tag x=\char`\"{}vec\%x\char`\"{} y=\char`\"{}vec\%y\char`\"{} z=\char`\"{}vec\%z\char`\"{}$>$ 

\begin{DoxyAuthor}{Author}
Ricardo Birjukovs Canelas -\/ M\+A\+R\+E\+T\+EC
\end{DoxyAuthor}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em xmlnode,tag,vec,mandatory} & \\
\hline
\mbox{\tt in}  & {\em xmlnode} & Working xml node\\
\hline
\mbox{\tt in}  & {\em tag} & Tag to search in xml node\\
\hline
\mbox{\tt out}  & {\em vec} & Vector to fill with read contents\\
\hline
\mbox{\tt out}  & {\em read\+\_\+flag} & Optional flag to capture read/non-\/read status\\
\hline
\mbox{\tt in}  & {\em mandatory} & Swich for optional or mandatory tags \\
\hline
\end{DoxyParams}


Definition at line 102 of file simulation\+\_\+xmlparser.\+f90.


\begin{DoxyCode}
102     \textcolor{keywordtype}{implicit none}
103     \textcolor{keywordtype}{type}(Node), \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{pointer} :: xmlnode
104     \textcolor{keywordtype}{type}(string), \textcolor{keywordtype}{intent(in)} :: tag
105     \textcolor{keywordtype}{type}(vector), \textcolor{keywordtype}{intent(out)} :: vec
106     \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{intent(out)}, \textcolor{keywordtype}{optional} :: read\_flag
107     \textcolor{keywordtype}{logical}, \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{optional} :: mandatory
108 
109     \textcolor{keywordtype}{type}(string) :: outext, nodename
110     \textcolor{keywordtype}{type}(NodeList), \textcolor{keywordtype}{pointer} :: target\_node\_list, nodeChildren
111     \textcolor{keywordtype}{type}(Node), \textcolor{keywordtype}{pointer} :: nodedetail
112     \textcolor{keywordtype}{logical} :: validtag
113     \textcolor{keywordtype}{integer} :: i
114 
115     vec%x=mv \textcolor{comment}{!marking the array as not read}
116     validtag = .false.
117     nodechildren => getchildnodes(xmlnode) \textcolor{comment}{!getting all of the nodes bellow the main source node (all of
       it's private info)}
118     \textcolor{keywordflow}{do} i=0, getlength(nodechildren)-1
119         nodedetail => item(nodechildren,i) \textcolor{comment}{!grabing a node}
120         nodename = getlocalname(nodedetail)  \textcolor{comment}{!finding its name}
121         \textcolor{keywordflow}{if} (nodename == tag) \textcolor{keywordflow}{then}
122             validtag =.true.
123             \textcolor{keywordflow}{exit}
124 \textcolor{keywordflow}{        endif}
125 \textcolor{keywordflow}{    enddo}
126     \textcolor{keywordflow}{if} (validtag) \textcolor{keywordflow}{then}
127         target\_node\_list => getelementsbytagname(xmlnode, tag%chars())   \textcolor{comment}{!searching for tags with the given
       name}
128         nodedetail => item(target\_node\_list, 0)
129         \textcolor{keyword}{call }extractdataattribute(nodedetail, \textcolor{stringliteral}{"x"}, vec%x)
130         \textcolor{keyword}{call }extractdataattribute(nodedetail, \textcolor{stringliteral}{"y"}, vec%y)
131         \textcolor{keyword}{call }extractdataattribute(nodedetail, \textcolor{stringliteral}{"z"}, vec%z)
132         \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(read\_flag)) \textcolor{keywordflow}{then}
133           read\_flag =.true.
134 \textcolor{keywordflow}{        endif}
135     \textcolor{keywordflow}{else}
136         \textcolor{keywordflow}{if}(\textcolor{keyword}{present}(mandatory)) \textcolor{keywordflow}{then}
137             \textcolor{keywordflow}{if}(mandatory.eqv..false.) \textcolor{keywordflow}{then}
138               \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(read\_flag)) \textcolor{keywordflow}{then}
139                 read\_flag =.false.
140 \textcolor{keywordflow}{              endif}
141 \textcolor{keywordflow}{            endif}
142         \textcolor{keywordflow}{else}
143             outext=\textcolor{stringliteral}{'Could not find any "'}//tag//\textcolor{stringliteral}{'" tag for xml node "'}//getnodename(xmlnode)//\textcolor{stringliteral}{'", stoping'}
144             \textcolor{keyword}{call }log%put(outext)
145             stop
146 \textcolor{keywordflow}{        endif}
147 \textcolor{keywordflow}{    endif}
\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacesimulation__xmlparser__mod_a48bcd153bef2149410d66842b564728d_icgraph}
\end{center}
\end{figure}
